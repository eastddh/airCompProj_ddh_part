# -*- coding: utf-8 -*-
"""lat_lon_rss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NUA7RKIK6hBbcqz9ZWJKYQczv_UlYfEs
"""

from __future__ import print_function, division
import os
import torch
import torch.nn.functional as F
from torch import nn, optim
from torch.autograd import Variable
import torchvision.transforms as transforms
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d 
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms, utils
import random
import matplotlib.pyplot as plt

class myDataset(Dataset):
    def __init__(self, csv_file, transform=None):
        """
        Args:
            csv_file (string): Path to the csv file with annotations.
            root_dir (string): Directory with all the images.
            transform (callable, optional): Optional transform to be applied
                on a sample.
        """
        self.data = pd.read_csv(csv_file)
        #self.root_dir = root_dir
        self.transform = transform
        n = len(self.data)
        self.old_pos = self.data.iloc[0:n,0:2]
        self.pos = self.data.iloc[0:n,0:2]
        self.old_pos = np.asarray(self.old_pos).astype('float').reshape(-1, 2)
        max_lat = max(self.old_pos[:,0])
        min_lat = min(self.old_pos[:,0])

        max_lon = max(self.old_pos[:,1])
        min_lon = min(self.old_pos[:,1])

        

        self.pos = self.data.iloc[0:n,0:2]
        self.pos = np.asarray(self.pos).astype('float').reshape(-1, 2)
        self.pos[:,0] = (self.pos[:,0] - min_lat)/(max_lat-min_lat)
        self.pos[:,1] = (self.pos[:,1] - min_lon)/(max_lon-min_lon)
        
        RSSI = self.data.iloc[0:n,2:3]
        self.RSSI = np.asarray(RSSI).astype('float').reshape(-1, 1)
        self.RSSI = self.RSSI

    def __len__(self):
        return int(len(self.data))

    def __getitem__(self, idx):
        if torch.is_tensor(idx):
            idx = idx.tolist()
        pos = np.array(self.pos[idx])
        RSSI = np.array(self.RSSI[idx])
        sample = {'positions':pos , 'RSSI': RSSI}

        if self.transform:
            sample = self.transform(sample)

        return sample

csv_file = 'test.csv'
testSet = myDataset(csv_file=csv_file)
print(len(testSet))
csv_file = 'train.csv'
trainSet = myDataset(csv_file=csv_file)
print(len(trainSet))

batch_size = 5
n_iters = 20000
epochs = n_iters / (len(trainSet) / batch_size)
result=[]
testRes=[]

net = torch.nn.Sequential(
    #torch.nn.BatchNorm1d(3),
    torch.nn.Linear(2, 100),
    torch.nn.BatchNorm1d(100,momentum = 0.9),
    torch.nn.LeakyReLU(),
    torch.nn.Linear(100, 100),
    torch.nn.BatchNorm1d(100,momentum = 0.9),
    torch.nn.LeakyReLU(),
    torch.nn.Linear(100, 1),
)
print(net)
#optimizer = torch.optim.Adam(net.parameters(), lr=1e-4)
optimizer = torch.optim.SGD(net.parameters(), lr=1e-4, momentum=0.9)
loss_func = torch.nn.MSELoss()
decayRate = 0.99
my_lr_scheduler = torch.optim.lr_scheduler.ExponentialLR(optimizer=optimizer, gamma=decayRate)
print(optimizer)
#print(my_lr_scheduler)

batch_size = 1000
n_iters = 20000
epochs = n_iters / (len(trainSet) / batch_size)
result=[]
testRes=[]
iter = 0
trainLoss = 0
base_norm = loss_func(torch.zeros(len(trainSet.RSSI),1), torch.from_numpy(trainSet.RSSI).float())
test_norm = loss_func(torch.zeros(len(testSet.RSSI),1), torch.from_numpy(testSet.RSSI).float())
for epoch in range(int(epochs)):
    trainLoss = 0
    for i in range(0,len(trainSet),batch_size):
        iter +=1
        positions = trainSet[i:i+batch_size]['positions']       
        positions = (torch.from_numpy(positions).float())      
        RSSI = trainSet[i:i+batch_size]['RSSI']
        RSSI = (torch.from_numpy(RSSI).float()) 
        optimizer.zero_grad()
        #print(positions)
        net.train()
        outputs = net(positions)
        loss = loss_func(outputs, RSSI) 
        #loss = torch.sqrt(mse)
        #print(epoch*len(trainSet)+i,loss.item())
        loss.backward()
        optimizer.step()
        trainLoss +=loss.item()* batch_size
   
        pos = testSet.pos
        pos = (torch.from_numpy(pos).float())
        rss = testSet.RSSI
        rss = (torch.from_numpy(rss).float())
        net.eval()
        outputs = net(pos)
        test_mse = loss_func(outputs, rss)
        test_loss = test_mse 
        testRes.append(test_loss.item())
        if epoch%100 ==0 and (i) % 5000==0 :
            print(" Iteration: {}. test Loss: {}.".format(i, testRes[-1]))
    
    result.append(trainLoss/len(trainSet))
    if epoch%100 ==0:
        my_lr_scheduler.step()
    if epoch%100 ==0:
        print("Epoch:{}.train Loss: {}".format(epoch, result[-1]))
print(len(result))
print(len(testRes))

fig = plt.figure(figsize = (10, 7))
plt.plot(result)
plt.title('train loss')
plt.ylabel('MSE')
plt.xlabel('training epoch')

nmse = []
for r in result:
    nmse.append(r/base_norm)
fig = plt.figure(figsize = (10, 7))
plt.plot(nmse)
plt.title('train loss')
plt.ylabel('NMSE')
plt.xlabel('training epoch')

fig = plt.figure(figsize = (10, 7))
plt.plot(testRes)
plt.title('test loss')
plt.ylabel('MSE')
plt.xlabel('training iteration')

test_nmse = []
for r in testRes:
    test_nmse.append(r/test_norm)
fig = plt.figure(figsize = (10, 7))
plt.plot(test_nmse)
plt.title('test loss')
plt.ylabel('NMSE')
plt.xlabel('training iteration')

fig = plt.figure(figsize = (10, 7))
ax = plt.axes(projection ="3d")
pos = testSet.pos
pos = (torch.from_numpy(pos).float())
rss = testSet.RSSI 
rss = (torch.from_numpy(rss).float())
net.eval()
pre_rss = net.forward(pos)
check = random.sample(range(50), 10)
print('check some of the test points')
print((pre_rss-rss)[check],'difference of predict and RSSI')
print('abs diff')
print((abs(pre_rss-rss)>10).sum(),'difference >10')
print((abs(pre_rss-rss)>20).sum(),'difference >20')
print((abs(pre_rss-rss)>30).sum(),'difference >30')
print('relative diff')
print((abs(pre_rss-rss)/abs(rss)>10).sum(),'difference >0.1')
print((abs(pre_rss-rss)/abs(rss)>20).sum(),'difference >0.05')
print((abs(pre_rss-rss)/abs(rss)>30).sum(),'difference >0.01')
print(max(pre_rss-rss),'max')
# Creating plot 
ax.scatter3D(pos[:,0].detach().numpy(), pos[:,1].detach().numpy(), rss.detach().numpy(), color = "blue");
ax.scatter3D(pos[:,0].detach().numpy(), pos[:,1].detach().numpy(), pre_rss.detach().numpy(), color = "green"); 
ax.legend(['RSSI', 'predictRSSI'])  
plt.title('RSSI')
plt.ylabel('longitude')
plt.xlabel('latitude')
#plt.legend()
plt.show()

